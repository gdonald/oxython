//! Virtual Machine for executing Python bytecode.
//!
//! This module provides the core VM implementation for the Oxython interpreter.
//! The VM executes bytecode generated by the compiler, managing:
//! - Stack-based evaluation of expressions and statements
//! - Function calls and call frames
//! - Variable scopes (global and local)
//! - Object-oriented programming features (classes, inheritance, methods)
//! - Closures and upvalue capture
//!
//! # Architecture
//!
//! The VM is organized into several submodules, each handling specific concerns:
//!
//! - [`call_frame`] - Call frame management for function calls
//! - [`collections`] - Collection utility functions (slicing, iteration)
//! - [`native`] - Native function implementations (e.g., `super()`)
//! - [`opcodes`] - Opcode handler implementations organized by category
//! - [`stack`] - Stack operations and management
//! - [`string_repr`] - Object string representation (`__str__`, `__repr__`)
//! - [`upvalues`] - Closure and upvalue management
//! - [`values`] - Value operations (e.g., truthiness checking)
//!
//! # Core Components
//!
//! ## VM Struct
//!
//! The [`VM`] struct maintains the interpreter state:
//! - **Stack**: Holds values during expression evaluation
//! - **Globals**: HashMap of global variables
//! - **Frames**: Call stack for function invocations
//! - **Open Upvalues**: Captured variables for closures
//!
//! ## Execution Flow
//!
//! 1. **Initialization**: Create a new VM with [`VM::new()`]
//! 2. **Interpretation**: Call [`VM::interpret()`] with a bytecode chunk
//! 3. **Execution**: The [`VM::run()`] method executes opcodes in a loop
//! 4. **Result**: Returns [`InterpretResult`] indicating success or error
//!
//! # Example
//!
//! ```rust,ignore
//! use oxython::vm::VM;
//!
//! let mut vm = VM::new();
//! let chunk = /* compiled bytecode */;
//! let result = vm.interpret(chunk);
//! ```
//!
//! # Opcode Categories
//!
//! The VM handles various categories of opcodes:
//!
//! - **Arithmetic**: `OpAdd`, `OpSubtract`, `OpMultiply`, `OpDivide`, `OpModulo`
//! - **Comparison**: `OpLess`, `OpEqual`
//! - **Collections**: `OpIndex`, `OpSlice`, `OpLen`, `OpAppend`, `OpRange`, `OpContains`
//! - **Control Flow**: `OpJump`, `OpJumpIfFalse`, `OpLoop`, `OpIterNext`
//! - **Functions**: `OpMakeFunction`, `OpCall`, `OpReturn`
//! - **Variables**: `OpGetLocal`, `OpSetLocal`, `OpGetGlobal`, `OpSetGlobal`, `OpGetUpvalue`, `OpSetUpvalue`
//! - **Classes**: `OpMakeClass`, `OpGetAttr`, `OpSetAttr`, `OpInherit`
//! - **Strings**: `OpStrLower`, `OpStrIsAlnum`, `OpStrJoin`
//! - **Builtins**: `OpRound`, `OpZip`, `OpToList`
//! - **Stack Operations**: `OpPop`, `OpDup`, `OpSwap`, `OpConstant`
//! - **I/O**: `OpPrint`, `OpPrintln`, `OpPrintSpaced`

mod call_frame;
pub mod collections;
pub mod native;
pub mod opcodes;
mod stack;
mod string_repr;
mod upvalues;
pub mod values;

use crate::bytecode::{Chunk, OpCode};
use crate::object::{ClassObject, FunctionObject, InstanceObject, Object, ObjectType, UpvalueRef};
use call_frame::{CallFrame, FRAMES_MAX};
use stack::Stack;
use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;

pub struct VM {
    stack: Stack,
    globals: HashMap<String, Object>,
    frames: Vec<CallFrame>,
    open_upvalues: Vec<UpvalueRef>,
}

#[derive(Debug, PartialEq)]
pub enum InterpretResult {
    Ok,
    CompileError,
    RuntimeError,
}

impl Default for VM {
    fn default() -> Self {
        Self::new()
    }
}

impl VM {
    pub fn new() -> Self {
        let mut vm = VM {
            stack: Stack::new(),
            globals: HashMap::new(),
            frames: Vec::new(),
            open_upvalues: Vec::new(),
        };
        vm.register_builtins();
        vm
    }

    fn register_builtins(&mut self) {
        native::register_builtins(&mut self.globals);
    }

    pub fn interpret(&mut self, chunk: Chunk) -> InterpretResult {
        self.stack.reset();
        self.frames.clear();
        self.open_upvalues.clear();

        let script_function = Rc::new(FunctionObject::new(
            "<script>".to_string(),
            0,
            chunk,
            Vec::new(),
            "<script>".to_string(),
        ));
        self.push(Rc::new(ObjectType::Function(script_function.clone())));
        self.frames
            .push(CallFrame::new(script_function, 0, None, None));

        self.run()
    }

    fn run(&mut self) -> InterpretResult {
        loop {
            if self.frames.is_empty() {
                return InterpretResult::Ok;
            }

            let instruction = OpCode::from(self.read_byte());

            match instruction {
                OpCode::OpConstant => {
                    let const_idx = self.read_byte() as usize;
                    let constant = self.current_chunk().constants[const_idx].clone();
                    self.push(constant);
                }
                OpCode::OpAdd => {
                    let b = self.pop();
                    let a = self.pop();
                    match opcodes::arithmetic::op_add(a, b) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpDivide => {
                    let b = self.pop();
                    let a = self.pop();
                    match opcodes::arithmetic::op_divide(a, b) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpSubtract => {
                    let b = self.pop();
                    let a = self.pop();
                    match opcodes::arithmetic::op_subtract(a, b) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpMultiply => {
                    let b = self.pop();
                    let a = self.pop();
                    match opcodes::arithmetic::op_multiply(a, b) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpModulo => {
                    let b = self.pop();
                    let a = self.pop();
                    match opcodes::arithmetic::op_modulo(a, b) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpDefineGlobal => {
                    let name_idx = self.read_byte() as usize;
                    if let ObjectType::String(name) = &*self.current_chunk().constants[name_idx] {
                        self.globals.insert(name.clone(), self.peek(0).clone());
                        self.pop();
                    }
                }
                OpCode::OpGetGlobal => {
                    let name_idx = self.read_byte() as usize;
                    if let ObjectType::String(name) = &*self.current_chunk().constants[name_idx] {
                        if let Some(value) = self.globals.get(name) {
                            self.push(value.clone());
                        } else {
                            // Runtime error: undefined variable
                            return InterpretResult::RuntimeError;
                        }
                    }
                }
                OpCode::OpSetGlobal => {
                    let name_idx = self.read_byte() as usize;
                    if let ObjectType::String(name) = &*self.current_chunk().constants[name_idx] {
                        if self.globals.contains_key(name) {
                            let value = self.peek(0).clone();
                            self.globals.insert(name.clone(), value);
                        } else {
                            return InterpretResult::RuntimeError;
                        }
                    }
                }
                OpCode::OpCall => {
                    let arg_count = self.read_byte() as usize;
                    if !self.call_value(arg_count) {
                        return InterpretResult::RuntimeError;
                    }
                }
                OpCode::OpMakeFunction => {
                    let proto_idx = self.read_byte() as usize;
                    let proto = match &*self.current_chunk().constants[proto_idx] {
                        ObjectType::FunctionPrototype(proto) => proto.clone(),
                        _ => return InterpretResult::RuntimeError,
                    };
                    let (frame_slot, parent_upvalues) = if let Some(frame) = self.frames.last() {
                        (frame.slot, frame.function.upvalues.clone())
                    } else {
                        (0, Vec::new())
                    };
                    let mut captured: Vec<UpvalueRef> = Vec::with_capacity(proto.upvalues.len());
                    for descriptor in proto.upvalues.iter() {
                        if descriptor.is_local {
                            let stack_index = frame_slot + descriptor.index;
                            let upvalue =
                                upvalues::capture_upvalue(&mut self.open_upvalues, stack_index);
                            captured.push(upvalue);
                        } else {
                            let upvalue = match parent_upvalues.get(descriptor.index) {
                                Some(value) => value.clone(),
                                None => return InterpretResult::RuntimeError,
                            };
                            captured.push(upvalue);
                        }
                    }
                    let type_info = crate::object::TypeInfo {
                        parameter_names: proto.parameter_names.clone(),
                        parameter_types: proto.parameter_types.clone(),
                        return_type: proto.return_type.clone(),
                        default_values: proto.default_values.clone(),
                    };
                    let mut function = FunctionObject::new_with_types(
                        proto.name.clone(),
                        proto.arity,
                        proto.chunk.clone(),
                        captured,
                        type_info,
                        proto.module.clone(),
                    );
                    function.doc = proto.doc.clone();
                    function.qualname = proto.qualname.clone();
                    // Capture a snapshot of the global namespace at function definition time
                    function.globals = self.globals.clone();
                    self.push(Rc::new(ObjectType::Function(Rc::new(function))));
                }
                OpCode::OpGetLocal => {
                    let slot = self.read_byte() as usize;
                    if let Some(frame) = self.frames.last() {
                        let index = frame.slot + slot;
                        let value = self.stack.get(index).clone();
                        self.push(value);
                    } else {
                        return InterpretResult::RuntimeError;
                    }
                }
                OpCode::OpSetLocal => {
                    let slot = self.read_byte() as usize;
                    if let Some(frame) = self.frames.last() {
                        let index = frame.slot + slot;
                        let value = self.peek(0).clone();
                        self.stack.set(index, value);
                    } else {
                        return InterpretResult::RuntimeError;
                    }
                }
                OpCode::OpGetUpvalue => {
                    let slot = self.read_byte() as usize;
                    let upvalue_ref = if let Some(frame) = self.frames.last() {
                        frame.function.upvalues.get(slot).cloned()
                    } else {
                        None
                    };
                    if let Some(upvalue_ref) = upvalue_ref {
                        let value = {
                            let upvalue = upvalue_ref.borrow();
                            if upvalue.is_closed {
                                upvalue.closed.clone()
                            } else {
                                self.stack.get(upvalue.location).clone()
                            }
                        };
                        self.push(value);
                    } else {
                        return InterpretResult::RuntimeError;
                    }
                }
                OpCode::OpSetUpvalue => {
                    let slot = self.read_byte() as usize;
                    let value = self.peek(0).clone();
                    let upvalue_ref = if let Some(frame) = self.frames.last() {
                        frame.function.upvalues.get(slot).cloned()
                    } else {
                        None
                    };
                    if let Some(upvalue_ref) = upvalue_ref {
                        let mut upvalue = upvalue_ref.borrow_mut();
                        if upvalue.is_closed {
                            upvalue.closed = value;
                        } else {
                            self.stack.set(upvalue.location, value);
                        }
                    } else {
                        return InterpretResult::RuntimeError;
                    }
                }
                OpCode::OpPrintSpaced => {
                    let value = self.pop();
                    let string_repr = string_repr::get_string_representation(
                        value.clone(),
                        &mut self.stack,
                        &mut self.frames,
                    );
                    if let Some(repr) = string_repr {
                        print!("{} ", repr);
                    } else {
                        // Fallback to default Display implementation
                        print!("{} ", value);
                    }
                }
                OpCode::OpPrint => {
                    let value = self.pop();
                    let string_repr = string_repr::get_string_representation(
                        value.clone(),
                        &mut self.stack,
                        &mut self.frames,
                    );
                    if let Some(repr) = string_repr {
                        print!("{}", repr);
                    } else {
                        // Fallback to default Display implementation
                        print!("{}", value);
                    }
                }
                OpCode::OpPrintln => {
                    println!();
                }
                OpCode::OpIndex => {
                    let index = self.pop();
                    let collection = self.pop();
                    match opcodes::collections::op_index(collection, index) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpLen => {
                    let value = self.pop();
                    match opcodes::collections::op_len(value) {
                        Ok(len) => self.push(Rc::new(ObjectType::Integer(len))),
                        Err(e) => return e,
                    }
                }
                OpCode::OpToList => {
                    let value = self.pop();
                    match opcodes::builtins::op_to_list(value) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpAppend => {
                    let value = self.pop();
                    let collection = self.pop();
                    match opcodes::collections::op_append(collection, value) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpRange => {
                    let end = self.pop();
                    let start = self.pop();
                    match opcodes::collections::op_range(start, end) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpLess => {
                    let b = self.pop();
                    let a = self.pop();
                    match opcodes::comparison::op_less(a, b) {
                        Ok(result) => self.push(Rc::new(ObjectType::Boolean(result))),
                        Err(e) => return e,
                    }
                }
                OpCode::OpEqual => {
                    let b = self.pop();
                    let a = self.pop();
                    let result = opcodes::comparison::op_equal(a, b);
                    self.push(Rc::new(ObjectType::Boolean(result)));
                }
                OpCode::OpSlice => {
                    let step = self.pop();
                    let end = self.pop();
                    let start = self.pop();
                    let collection = self.pop();
                    match opcodes::collections::op_slice(collection, start, end, step) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpStrLower => {
                    let value = self.pop();
                    match opcodes::strings::op_str_lower(value) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpStrIsAlnum => {
                    let value = self.pop();
                    match opcodes::strings::op_str_is_alnum(value) {
                        Ok(result) => self.push(Rc::new(ObjectType::Boolean(result))),
                        Err(e) => return e,
                    }
                }
                OpCode::OpStrJoin => {
                    let iterable = self.pop();
                    let separator = self.pop();
                    match opcodes::strings::op_str_join(separator, iterable) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpRound => {
                    let digits = self.pop();
                    let value = self.pop();
                    match opcodes::builtins::op_round(value, digits) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpZip => {
                    let arg_count = self.read_byte() as usize;
                    let star_mask = self.read_u16() as u16;

                    let mut args = Vec::with_capacity(arg_count);
                    for _ in 0..arg_count {
                        args.push(self.pop());
                    }
                    args.reverse();

                    match opcodes::builtins::op_zip(args, star_mask) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpReturn => {
                    if self.handle_return() {
                        return InterpretResult::Ok;
                    }
                }
                OpCode::OpPop => {
                    self.pop();
                }
                OpCode::OpIterNext => {
                    let offset = self.read_u16();
                    let index = self.pop();
                    let collection = self.pop();

                    match (&*collection, &*index) {
                        (ObjectType::List(values), ObjectType::Integer(idx))
                        | (ObjectType::Tuple(values), ObjectType::Integer(idx)) => {
                            if *idx < 0 {
                                return InterpretResult::RuntimeError;
                            }
                            let idx_usize = *idx as usize;
                            if idx_usize >= values.len() {
                                // Iteration finished; skip body.
                                if let Some(frame) = self.frames.last_mut() {
                                    frame.ip += offset;
                                }
                            } else {
                                let element = values[idx_usize].clone();
                                let next_index = (idx_usize + 1) as i64;
                                self.push(collection.clone());
                                self.push(Rc::new(ObjectType::Integer(next_index)));
                                self.push(element);
                            }
                        }
                        (ObjectType::String(text), ObjectType::Integer(idx)) => {
                            if *idx < 0 {
                                return InterpretResult::RuntimeError;
                            }
                            let chars: Vec<char> = text.chars().collect();
                            let idx_usize = *idx as usize;
                            if idx_usize >= chars.len() {
                                if let Some(frame) = self.frames.last_mut() {
                                    frame.ip += offset;
                                }
                            } else {
                                let ch = chars[idx_usize];
                                let next_index = (idx_usize + 1) as i64;
                                self.push(collection.clone());
                                self.push(Rc::new(ObjectType::Integer(next_index)));
                                self.push(Rc::new(ObjectType::String(ch.to_string())));
                            }
                        }
                        _ => {
                            return InterpretResult::RuntimeError;
                        }
                    }
                }
                OpCode::OpLoop => {
                    let offset = self.read_u16();
                    if let Some(frame) = self.frames.last_mut() {
                        frame.ip -= offset;
                    }
                }
                OpCode::OpJumpIfFalse => {
                    let offset = self.read_u16();
                    let condition = self.peek(0).clone();
                    if !values::is_truthy(&condition) {
                        if let Some(frame) = self.frames.last_mut() {
                            frame.ip += offset;
                        }
                    }
                }
                OpCode::OpJump => {
                    let offset = self.read_u16();
                    if let Some(frame) = self.frames.last_mut() {
                        frame.ip += offset;
                    }
                }
                OpCode::OpSetIndex => {
                    let value = self.pop();
                    let index = self.pop();
                    let collection = self.pop();
                    match opcodes::collections::op_set_index(collection, index, value) {
                        Ok(result) => self.push(result),
                        Err(e) => return e,
                    }
                }
                OpCode::OpDup => {
                    let value = self.peek(0).clone();
                    self.push(value);
                }
                OpCode::OpContains => {
                    let collection = self.pop();
                    let item = self.pop();
                    match opcodes::collections::op_contains(item, collection) {
                        Ok(result) => self.push(Rc::new(ObjectType::Boolean(result))),
                        Err(e) => return e,
                    }
                }
                OpCode::OpSwap => {
                    let base = self.frames.last().map(|frame| frame.slot + 1).unwrap_or(0);
                    if self.stack.top() < base + 2 {
                        return InterpretResult::RuntimeError;
                    }
                    self.stack.swap(self.stack.top() - 1, self.stack.top() - 2);
                }
                OpCode::OpMakeClass => {
                    let method_count = self.read_byte() as usize;

                    // Pop class name
                    let class_name = match &*self.pop() {
                        ObjectType::String(name) => name.clone(),
                        _ => return InterpretResult::RuntimeError,
                    };

                    // Pop method names (in reverse order)
                    let mut method_names = Vec::with_capacity(method_count);
                    for _ in 0..method_count {
                        let method_name = match &*self.pop() {
                            ObjectType::String(name) => name.clone(),
                            _ => return InterpretResult::RuntimeError,
                        };
                        method_names.push(method_name);
                    }

                    // Method names are in reverse order, so reverse them back
                    method_names.reverse();

                    // Now pop method functions (they're below the names on stack)
                    let mut method_funcs = Vec::with_capacity(method_count);
                    for _ in 0..method_count {
                        method_funcs.push(self.pop());
                    }

                    // Functions are in reverse order too
                    method_funcs.reverse();

                    // Pair up names and functions
                    let mut methods = HashMap::new();
                    for (name, func) in method_names.into_iter().zip(method_funcs.into_iter()) {
                        methods.insert(name, func);
                    }

                    let class = Rc::new(ClassObject::new(class_name, methods));
                    self.push(Rc::new(ObjectType::Class(class)));
                }
                OpCode::OpGetAttr => {
                    let attr_idx = self.read_byte() as usize;
                    let attr_name = match &*self.current_chunk().constants[attr_idx] {
                        ObjectType::String(name) => name.clone(),
                        _ => return InterpretResult::RuntimeError,
                    };

                    let object = self.pop();
                    match &*object {
                        ObjectType::Instance(instance_ref) => {
                            let instance = instance_ref.borrow();

                            // First check instance fields
                            if let Some(value) = instance.get_field(&attr_name) {
                                self.push(value);
                            } else if let Some(method) = instance.class.get_method(&attr_name) {
                                // Create a bound method (using inheritance chain)
                                let bound = Rc::new(ObjectType::BoundMethod(
                                    object.clone(),
                                    method.clone(),
                                ));
                                self.push(bound);
                            } else {
                                return InterpretResult::RuntimeError;
                            }
                        }
                        ObjectType::Class(class) => {
                            // Access method from class directly (using inheritance chain)
                            if let Some(method) = class.get_method(&attr_name) {
                                self.push(method.clone());
                            } else {
                                return InterpretResult::RuntimeError;
                            }
                        }
                        ObjectType::SuperProxy(instance, parent_class) => {
                            // Look up method in the parent class only (not the full chain)
                            if let Some(method) = parent_class.get_method(&attr_name) {
                                // Create a bound method with the instance
                                let bound = Rc::new(ObjectType::BoundMethod(
                                    instance.clone(),
                                    method.clone(),
                                ));
                                self.push(bound);
                            } else {
                                return InterpretResult::RuntimeError;
                            }
                        }
                        ObjectType::Function(func) => {
                            // Function introspection attributes
                            match attr_name.as_str() {
                                "__name__" => {
                                    let name = Rc::new(ObjectType::String(func.name.clone()));
                                    self.push(name);
                                }
                                "__module__" => {
                                    let module = Rc::new(ObjectType::String(func.module.clone()));
                                    self.push(module);
                                }
                                "__doc__" => {
                                    let doc = match &func.doc {
                                        Some(docstring) => {
                                            Rc::new(ObjectType::String(docstring.clone()))
                                        }
                                        None => Rc::new(ObjectType::Nil),
                                    };
                                    self.push(doc);
                                }
                                "__annotations__" => {
                                    // Build a Dict with parameter names and type annotations
                                    let mut annotations: Vec<(String, Object)> = Vec::new();

                                    // Add parameter type annotations
                                    for (i, param_name) in func.parameter_names.iter().enumerate() {
                                        if let Some(Some(param_type)) = func.parameter_types.get(i)
                                        {
                                            let type_str = Rc::new(ObjectType::String(
                                                param_type.name().to_string(),
                                            ));
                                            annotations.push((param_name.clone(), type_str));
                                        }
                                    }

                                    // Add return type annotation with 'return' key
                                    if let Some(return_type) = &func.return_type {
                                        let type_str = Rc::new(ObjectType::String(
                                            return_type.name().to_string(),
                                        ));
                                        annotations.push(("return".to_string(), type_str));
                                    }

                                    let annotations_dict = Rc::new(ObjectType::Dict(annotations));
                                    self.push(annotations_dict);
                                }
                                "__code__" => {
                                    // Return a reference to the function's bytecode chunk
                                    let code_obj =
                                        Rc::new(ObjectType::CodeObject(func.chunk.clone()));
                                    self.push(code_obj);
                                }
                                "__qualname__" => {
                                    let qualname =
                                        Rc::new(ObjectType::String(func.qualname.clone()));
                                    self.push(qualname);
                                }
                                "__globals__" => {
                                    // Convert HashMap to Dict format (Vec<(String, Object)>)
                                    let globals_vec: Vec<(String, Object)> = func
                                        .globals
                                        .iter()
                                        .map(|(k, v)| (k.clone(), v.clone()))
                                        .collect();
                                    let globals_dict = Rc::new(ObjectType::Dict(globals_vec));
                                    self.push(globals_dict);
                                }
                                "__closure__" => {
                                    // Return a tuple of cell objects (upvalues), or None if no closure
                                    if func.upvalues.is_empty() {
                                        self.push(Rc::new(ObjectType::Nil));
                                    } else {
                                        // Create a tuple containing the closed-over values
                                        let cell_values: Vec<Object> = func
                                            .upvalues
                                            .iter()
                                            .map(|upvalue_ref| {
                                                let upvalue = upvalue_ref.borrow();
                                                if upvalue.is_closed {
                                                    // Use the closed value
                                                    upvalue.closed.clone()
                                                } else {
                                                    // Read from stack at location
                                                    self.stack.get(upvalue.location).clone()
                                                }
                                            })
                                            .collect();
                                        let closure_tuple = Rc::new(ObjectType::Tuple(cell_values));
                                        self.push(closure_tuple);
                                    }
                                }
                                "__defaults__" => {
                                    // Return a tuple of default values for parameters, or None if no defaults
                                    // Collect only the default values (not None placeholders)
                                    let defaults: Vec<Object> = func
                                        .default_values
                                        .iter()
                                        .filter_map(|opt| opt.clone())
                                        .collect();

                                    if defaults.is_empty() {
                                        self.push(Rc::new(ObjectType::Nil));
                                    } else {
                                        let defaults_tuple = Rc::new(ObjectType::Tuple(defaults));
                                        self.push(defaults_tuple);
                                    }
                                }
                                _ => return InterpretResult::RuntimeError,
                            }
                        }
                        ObjectType::FunctionPrototype(proto) => {
                            // Function prototype introspection attributes
                            match attr_name.as_str() {
                                "__name__" => {
                                    let name = Rc::new(ObjectType::String(proto.name.clone()));
                                    self.push(name);
                                }
                                "__module__" => {
                                    let module = Rc::new(ObjectType::String(proto.module.clone()));
                                    self.push(module);
                                }
                                "__doc__" => {
                                    let doc = match &proto.doc {
                                        Some(docstring) => {
                                            Rc::new(ObjectType::String(docstring.clone()))
                                        }
                                        None => Rc::new(ObjectType::Nil),
                                    };
                                    self.push(doc);
                                }
                                "__annotations__" => {
                                    // Build a Dict with parameter names and type annotations
                                    let mut annotations: Vec<(String, Object)> = Vec::new();

                                    // Add parameter type annotations
                                    for (i, param_name) in proto.parameter_names.iter().enumerate()
                                    {
                                        if let Some(Some(param_type)) = proto.parameter_types.get(i)
                                        {
                                            let type_str = Rc::new(ObjectType::String(
                                                param_type.name().to_string(),
                                            ));
                                            annotations.push((param_name.clone(), type_str));
                                        }
                                    }

                                    // Add return type annotation with 'return' key
                                    if let Some(return_type) = &proto.return_type {
                                        let type_str = Rc::new(ObjectType::String(
                                            return_type.name().to_string(),
                                        ));
                                        annotations.push(("return".to_string(), type_str));
                                    }

                                    let annotations_dict = Rc::new(ObjectType::Dict(annotations));
                                    self.push(annotations_dict);
                                }
                                "__code__" => {
                                    // Return a reference to the prototype's bytecode chunk
                                    let code_obj =
                                        Rc::new(ObjectType::CodeObject(proto.chunk.clone()));
                                    self.push(code_obj);
                                }
                                "__qualname__" => {
                                    let qualname =
                                        Rc::new(ObjectType::String(proto.qualname.clone()));
                                    self.push(qualname);
                                }
                                "__globals__" => {
                                    // Prototypes don't have globals captured yet - return empty dict
                                    let empty_dict = Rc::new(ObjectType::Dict(Vec::new()));
                                    self.push(empty_dict);
                                }
                                "__closure__" => {
                                    // Prototypes are templates, not runtime closures
                                    // Return None since closures are only created at runtime
                                    self.push(Rc::new(ObjectType::Nil));
                                }
                                "__defaults__" => {
                                    // Return a tuple of default values for parameters, or None if no defaults
                                    // Collect only the default values (not None placeholders)
                                    let defaults: Vec<Object> = proto
                                        .default_values
                                        .iter()
                                        .filter_map(|opt| opt.clone())
                                        .collect();

                                    if defaults.is_empty() {
                                        self.push(Rc::new(ObjectType::Nil));
                                    } else {
                                        let defaults_tuple = Rc::new(ObjectType::Tuple(defaults));
                                        self.push(defaults_tuple);
                                    }
                                }
                                _ => return InterpretResult::RuntimeError,
                            }
                        }
                        _ => return InterpretResult::RuntimeError,
                    }
                }
                OpCode::OpSetAttr => {
                    let attr_idx = self.read_byte() as usize;
                    let attr_name = match &*self.current_chunk().constants[attr_idx] {
                        ObjectType::String(name) => name.clone(),
                        _ => return InterpretResult::RuntimeError,
                    };

                    let value = self.pop();
                    let object = self.pop();

                    match &*object {
                        ObjectType::Instance(instance_ref) => {
                            instance_ref.borrow_mut().set_field(attr_name, value);
                        }
                        _ => return InterpretResult::RuntimeError,
                    }
                }
                OpCode::OpInherit => {
                    // Stack: [child_class, parent_class]
                    let parent = self.pop();
                    let child = self.pop();

                    // Ensure parent is a class
                    let parent_class = match &*parent {
                        ObjectType::Class(class) => class.clone(),
                        _ => return InterpretResult::RuntimeError,
                    };

                    // Ensure child is a class
                    let child_class = match &*child {
                        ObjectType::Class(class) => class,
                        _ => return InterpretResult::RuntimeError,
                    };

                    // Create new class with parent set
                    let new_child = Rc::new(ClassObject::new_with_parent(
                        child_class.name.clone(),
                        child_class.methods.clone(),
                        parent_class,
                    ));

                    // Push the updated child class back
                    self.push(Rc::new(ObjectType::Class(new_child)));
                }
            }
        }
    }

    fn push(&mut self, value: Object) {
        self.stack.push(value);
    }

    fn pop(&mut self) -> Object {
        self.stack.pop()
    }

    fn peek(&self, distance: usize) -> &Object {
        self.stack.peek(distance)
    }

    pub fn last_popped_stack_elem(&self) -> Rc<ObjectType> {
        self.stack.last_popped()
    }

    // Helper for testing to inspect the top of the stack without popping.
    pub fn peek_stack(&self) -> Option<Rc<ObjectType>> {
        self.stack.peek_top()
    }

    fn current_chunk(&self) -> &Chunk {
        &self
            .frames
            .last()
            .expect("expected active call frame")
            .function
            .chunk
    }

    fn read_byte(&mut self) -> u8 {
        let frame = self.frames.last_mut().expect("expected active call frame");
        let byte = frame.function.chunk.code[frame.ip];
        frame.ip += 1;
        byte
    }

    fn call_value(&mut self, arg_count: usize) -> bool {
        if self.stack.top() < arg_count + 1 {
            return false;
        }
        let callee_index = self.stack.top() - arg_count - 1;
        let callee = self.stack.get(callee_index).clone();
        match &*callee {
            ObjectType::Function(function) => {
                self.call_function(function.clone(), callee_index, arg_count, None, None)
            }
            ObjectType::NativeFunction(name, func) => {
                // Special handling for super() - it needs access to self
                if name == "super" {
                    // Get the class context from the current frame
                    let class_context = self.frames.last().and_then(|f| f.class_context.clone());

                    // Get 'self' from the current frame's first local variable (slot + 1)
                    let self_instance = if let Some(frame) = self.frames.last() {
                        self.stack.get(frame.slot + 1).clone()
                    } else {
                        return false;
                    };

                    // Call the native function with self as an argument
                    let args = [self_instance];
                    match func(&args, class_context) {
                        Ok(result) => {
                            self.stack.set_top(callee_index);
                            self.push(result);
                            true
                        }
                        Err(_) => false,
                    }
                } else {
                    // General native function call
                    let class_context = self.frames.last().and_then(|f| f.class_context.clone());
                    let args: Vec<Object> = (0..arg_count)
                        .map(|i| self.stack.get(callee_index + 1 + i).clone())
                        .collect();
                    match func(&args, class_context) {
                        Ok(result) => {
                            self.stack.set_top(callee_index);
                            self.push(result);
                            true
                        }
                        Err(_) => false,
                    }
                }
            }
            ObjectType::Class(class) => {
                // Create instance
                let instance = Rc::new(RefCell::new(InstanceObject::new(class.clone())));
                let instance_obj = Rc::new(ObjectType::Instance(instance.clone()));

                // Look for __init__ method (traverses inheritance chain)
                if let Some(init_method) = class.get_method("__init__") {
                    if let ObjectType::Function(init_func) = &*init_method {
                        // Stack layout: [class, arg1, arg2, ...]
                        // We want: [instance, instance, arg1, arg2, ...] so that after __init__ returns,
                        // one instance remains

                        // Push instance at the callee position
                        self.stack.set(callee_index, instance_obj.clone());

                        // Insert instance as self parameter
                        // Shift arguments up by one to make room for self
                        let stack_top = self.stack.top();
                        for i in (callee_index + 1..stack_top).rev() {
                            let value = self.stack.get(i).clone();
                            self.stack.set(i + 1, value);
                        }
                        self.stack.set(callee_index + 1, instance_obj.clone());
                        self.stack.set_top(stack_top + 1);

                        // Save instance beyond the call frame so it doesn't get overwritten
                        let new_top = self.stack.top();
                        self.stack.set(new_top, instance_obj.clone());
                        let saved_instance_slot = new_top;
                        self.stack.set_top(new_top + 1);

                        // Now call __init__: [instance, self(instance), arg1, arg2, ..., saved_instance]
                        // Pass the saved_instance_slot to call_function so handle_return can restore it
                        // Pass the class as context for super() to work in __init__
                        return self.call_function(
                            init_func.clone(),
                            callee_index,
                            arg_count + 1,
                            Some(saved_instance_slot),
                            Some(class.clone()),
                        );
                    }
                }

                // No __init__, just return the instance
                self.stack.set(callee_index, instance_obj);
                self.stack.set_top(callee_index + 1);
                true
            }
            ObjectType::BoundMethod(instance, method) => {
                // Insert the instance as first parameter
                // Stack layout: [bound_method, arg1, arg2, ...]
                // Need: [bound_method, instance(self), arg1, arg2, ...]

                // Shift arguments to make room for self
                let stack_top = self.stack.top();
                for i in (callee_index + 1..stack_top).rev() {
                    let value = self.stack.get(i).clone();
                    self.stack.set(i + 1, value);
                }
                // Insert instance as first parameter
                self.stack.set(callee_index + 1, instance.clone());
                self.stack.set_top(stack_top + 1);

                // Get the class context from the instance for super() support
                let class_context = if let ObjectType::Instance(inst_ref) = &**instance {
                    Some(inst_ref.borrow().class.clone())
                } else {
                    None
                };

                match &**method {
                    ObjectType::Function(function) => {
                        // Call with arg_count + 1 (including self)
                        // slot points to bound_method, parameters start at slot+1
                        self.call_function(
                            function.clone(),
                            callee_index,
                            arg_count + 1,
                            None,
                            class_context,
                        )
                    }
                    _ => false,
                }
            }
            _ => false,
        }
    }

    fn call_function(
        &mut self,
        function: Rc<FunctionObject>,
        callee_index: usize,
        arg_count: usize,
        instance_slot: Option<usize>,
        class_context: Option<Rc<ClassObject>>,
    ) -> bool {
        // Validate argument count with default parameters support
        // arg_count must be between required_args and arity (inclusive)
        if arg_count < function.required_args || arg_count > function.arity {
            return false;
        }

        if self.frames.len() >= FRAMES_MAX {
            return false;
        }

        // Fill in missing arguments with default values
        if arg_count < function.arity {
            // Push default values for missing parameters
            for i in arg_count..function.arity {
                if let Some(Some(default_value)) = function.default_values.get(i) {
                    self.push(default_value.clone());
                } else {
                    // This should not happen if required_args is calculated correctly
                    return false;
                }
            }
        }

        self.frames.push(CallFrame::new(
            function,
            callee_index,
            instance_slot,
            class_context,
        ));
        true
    }

    fn handle_return(&mut self) -> bool {
        let (frame_slot, frame_arity, instance_slot) = if let Some(frame) = self.frames.last() {
            (frame.slot, frame.function.arity, frame.instance_slot)
        } else {
            (0, 0, None)
        };
        // Stack layout: [callee/function, params...] [return_value?]
        // frame_slot points to callee, params start at frame_slot+1
        // Return value (if any) is at frame_slot + arity + 1
        // So if there's a return value, stack_top > frame_slot + arity + 1
        let minimum_stack = frame_slot + frame_arity + 1;
        let result = if self.stack.top() > minimum_stack {
            Some(self.pop())
        } else {
            None
        };

        // Save the instance BEFORE resetting stack_top
        let saved_instance = instance_slot.map(|slot| self.stack.get(slot).clone());

        upvalues::close_upvalues(&mut self.open_upvalues, &self.stack, frame_slot);

        self.frames.pop();
        self.stack.set_top(frame_slot);

        if self.frames.is_empty() {
            if let Some(value) = result {
                self.stack.set_last_popped(value.clone());
                self.push(value);
            }
            true
        } else {
            // Check if this was an __init__ call
            let value = if let Some(instance) = saved_instance {
                // Return the saved instance instead of the function's return value
                instance
            } else {
                result.unwrap_or_else(|| Rc::new(ObjectType::Nil))
            };
            self.stack.set_last_popped(value.clone());
            self.push(value);
            false
        }
    }

    fn read_u16(&mut self) -> usize {
        let high = self.read_byte() as usize;
        let low = self.read_byte() as usize;
        (high << 8) | low
    }
}
